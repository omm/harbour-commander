#line 48 "harbour-commander\hc.prg"
STATIC aPanelLeft
STATIC aPanelRight
STATIC aPanelSelect
STATIC aConfig

PROCEDURE Main()

   Set( 4, "yyyy-mm-dd" )
   Set( 32, .F. )
   Set( 39, hb_bitOr( 128, 1024, ( 128 + 1 + 2 + 4 + 8 + 16 + 32 + 64 ) ) )
   Set( 29, .T. )


   hb_cdpSelect( "UTF8EX" )
   hb_gtInfo( 9, .F. )
   hb_gtInfo( 57, hb_cdpSelect() )


   hb_SetTermCP( hb_cdpTerm() )
   Set( 115, hb_cdpOS() )
   Set( 117, "EN" )

   hb_gtInfo( 54, 1 )
   hb_gtInfo( 26, "Harbour Commander" )

   aPanelLeft := PanelInit()
   aPanelRight := PanelInit()



   aConfig := hb_deserialize( hb_memoread( "hc.cfg" ) )
   if ! HB_ISARRAY( aConfig )
      ConfigInit()
   ENDIF
   PanelFetchList( aPanelLeft, aConfig[ 1 ] )
   PanelFetchList( aPanelRight, aConfig[ 2 ] )

   AutoSize()

   aPanelSelect := aConfig[ 3 ]

   Prompt()

   hb_Scroll()
   SetPos( 0, 0 )

   RETURN

STATIC PROCEDURE ConfigInit()

   aConfig := Array( 3 )

   aConfig[ 1  ] := hb_cwd()
   aConfig[ 2 ] := hb_cwd()
   aConfig[ 3 ] := iif( aPanelSelect == NIL, aPanelLeft, aPanelSelect )

   RETURN

STATIC FUNCTION PanelInit()

   LOCAL aInit

   aInit := Array( 11 )

   aInit[ 1        ] := 0
   aInit[ 2       ] := 0
   aInit[ 3     ] := 0
   aInit[ 4      ] := 0
   aInit[ 5 ] := ""
   aInit[ 6  ] := {}
   aInit[ 7     ] := 1
   aInit[ 8      ] := 0
   aInit[ 9   ] := ""
   aInit[ 10    ] := 0
   aInit[ 11  ] := 0

   RETURN aInit

STATIC PROCEDURE PanelFetchList( aPanel, cDir )

   LOCAL i, nPos, a2Dot, aDots := { ".", ".." }, iDot

   CheckDirExists( @cDir )

   aPanel[ 5 ] := cDir
   aPanel[ 6 ] := hb_vfDirectory( aPanel[ 5 ], "HSD" )


   FOR i := 1 TO Len( aPanel[ 6 ] )
      AAdd( aPanel[ 6 ][ i ], .T. )
   NEXT

   FOR EACH iDot in aDots
      IF ( nPos := AScan( aPanel[ 6 ], {| x | x[ 1 ] == iDot } ) ) > 0
         IF iDot:__enumIndex == 2
            a2Dot := aPanel[ 6 ][ nPos ]
         ENDIF
         hb_ADel( aPanel[ 6 ], nPos, .T. )
      ENDIF
   NEXT
   ASort( aPanel[ 6 ],,, {| x, y | iif( "D" $ x[ 5 ], "A", "B" ) + Upper( x[ 1 ] ) < iif( "D" $ y[ 5 ], "A", "B" ) + Upper( y[ 1 ] ) } )
   IF HB_ISARRAY( a2Dot )
      hb_AIns( aPanel[ 6 ], 1, a2Dot, .T. )
   ENDIF

   RETURN

STATIC PROCEDURE CheckDirExists( cDir )

   LOCAL nPs

   WHILE ! hb_DirExists( cDir )
      nPs := hb_Rat( hb_ps(), cDir,, iif( Right( cDir, 1 ) == hb_ps(), Len( cDir ) - 1, NIL ) )
      cDir := SubStr( cDir, 1, nPs )
      CheckDirExists( @cDir )
   END

   RETURN


STATIC PROCEDURE AutoSize()

   Resize( aPanelLeft, 0, 0, MaxRow() - 2, MaxCol() / 2 )
   Resize( aPanelRight, 0, MaxCol() / 2 + 1, MaxRow() - 2, MaxCol() )

   RETURN

STATIC PROCEDURE Resize( aPanel, nTop, nLeft, nBottom, nRight )

   aPanel[ 1    ] := nTop
   aPanel[ 2   ] := nLeft
   aPanel[ 3 ] := nBottom
   aPanel[ 4  ] := nRight

   RETURN

STATIC PROCEDURE Prompt()

   LOCAL lContinue := .T.
   LOCAL nMaxRow := 0, nMaxCol := 0
   LOCAL nKey, nKeyStd
   LOCAL nPos
   LOCAL cFileName
   LOCAL pHandle
   LOCAL nMRow, nMCol
   LOCAL nCol
   LOCAL cSpaces
   LOCAL nErrorCode
   LOCAL cNewDrive
   LOCAL i










   while lContinue

      DispBegin()

      IF nMaxRow <> MaxRow() .OR. nMaxCol <> MaxCol()

         hb_Scroll()
         AutoSize()

         PanelDisplay( aPanelLeft )
         PanelDisplay( aPanelRight )

         ComdLineDisplay( aPanelSelect )

         BottomBar()

         nMaxRow := MaxRow()
         nMaxCol := MaxCol()
      ENDIF

      DispEnd()

      ComdLineDisplay( aPanelSelect )
      PanelDisplay( aPanelSelect )

      nKey := Inkey( 0 )
      nKeyStd := hb_keyStd( nKey )

      SWITCH nKeyStd

      CASE 27

         IF ! Empty( aPanelSelect[ 9 ] )
            aPanelSelect[ 9 ] := ""
            aPanelSelect[ 10 ] := 0
            ComdLineDisplay( aPanelSelect )
         ELSE
            lContinue := .F.

            aConfig[ 1  ] := aPanelLeft[ 5 ]
            aConfig[ 2 ] := aPanelRight[ 5 ]
            aConfig[ 3 ] := aPanelSelect
            hb_MemoWrit( StartUpPath() + "hc.cfg", hb_Serialize( aConfig ) )
         ENDIF
         EXIT

      CASE 13

         nPos := aPanelSelect[ 7 ] + aPanelSelect[ 8 ]
         IF Empty( aPanelSelect[ 9 ] )

            IF At( "D", aPanelSelect[ 6 ][ nPos ][ 5 ] ) == 0

               hb_run( Chr( 34 ) + aPanelSelect[ 5 ] + aPanelSelect[ 6 ][ nPos ][ 1 ] + Chr( 34 ) )




















            ELSE
               ChangeDir( aPanelSelect )
            ENDIF
         ELSE



            hb_Scroll()
            hb_run( aPanelSelect[ 9 ] )
            aPanelSelect[ 9 ] := ""
            Inkey( 0 )
            nMaxRow := 0
            aPanelSelect[ 10 ] := 0

            PanelRefresh( aPanelSelect )
         ENDIF

         EXIT

      CASE 9

         IF aPanelSelect == aPanelLeft
            aPanelSelect := aPanelRight
            aPanelSelect[ 9 ] := aPanelLeft[ 9 ]
            aPanelSelect[ 10 ] := aPanelLeft[ 10 ]
            aPanelLeft[ 9 ] := ""
            aPanelLeft[ 10 ] := 0
         ELSE
            aPanelSelect := aPanelLeft
            aPanelSelect[ 9 ] := aPanelRight[ 9 ]
            aPanelSelect[ 10 ] := aPanelRight[ 10 ]
            aPanelRight[ 9 ] := ""
            aPanelRight[ 10 ] := 0
         ENDIF

         PanelDisplay( aPanelLeft )
         PanelDisplay( aPanelRight )
         EXIT

      CASE 1001

         DispBegin()

         nMRow := MRow()
         nCol := Int( nMaxCol / 10 ) + 1

         BottomBar()
         IF nMRow > nMaxRow - 1

            cSpaces := Space( nCol - 8 )

            SWITCH Int( MCol() / nCol ) + 1
            CASE 1  ; hb_DispOutAt( nMRow, 2,            "Help  " + cSpaces, 0xb0 ) ; EXIT
            CASE 2  ; hb_DispOutAt( nMRow, nCol + 2,     "Menu  " + cSpaces, 0xb0 ) ; EXIT
            CASE 3  ; hb_DispOutAt( nMRow, nCol * 2 + 2, "View  " + cSpaces, 0xb0 ) ; EXIT
            CASE 4  ; hb_DispOutAt( nMRow, nCol * 3 + 2, "Edit  " + cSpaces, 0xb0 ) ; EXIT
            CASE 5  ; hb_DispOutAt( nMRow, nCol * 4 + 2, "Copy  " + cSpaces, 0xb0 ) ; EXIT
            CASE 6  ; hb_DispOutAt( nMRow, nCol * 5 + 2, "RenMov" + cSpaces, 0xb0 ) ; EXIT
            CASE 7  ; hb_DispOutAt( nMRow, nCol * 6 + 2, "MkDir " + cSpaces, 0xb0 ) ; EXIT
            CASE 8  ; hb_DispOutAt( nMRow, nCol * 7 + 2, "Delete" + cSpaces, 0xb0 ) ; EXIT
            CASE 9  ; hb_DispOutAt( nMRow, nCol * 8 + 2, "PullDn" + cSpaces, 0xb0 ) ; EXIT
            CASE 10 ; hb_DispOutAt( nMRow, nCol * 9 + 2, "Quit  " + cSpaces, 0xb0 ) ; EXIT
            ENDSWITCH

         ENDIF

         DispEnd()
         EXIT

      CASE 1006

         nPos := aPanelSelect[ 7 ] + aPanelSelect[ 8 ]

         IF At( "D", aPanelSelect[ 6 ][ nPos ][ 5 ] ) == 0

            hb_run( Chr( 34 ) + aPanelSelect[ 5 ] + aPanelSelect[ 6 ][ nPos ][ 1 ] + Chr( 34 ) )




















         ELSE
            ChangeDir( aPanelSelect )
         ENDIF

         EXIT

      CASE 1004

         nMRow := MRow()
         nMCol := MCol()

         IF nMRow > 0 .AND. nMRow < MaxRow() - 1 .AND. nMCol < Int( MaxCol() / 2 ) + 1
            aPanelSelect := aPanelLeft
            IF nMRow <= Len( aPanelSelect[ 6 ] )
               aPanelSelect[ 7 ] := nMRow
            ENDIF
         ENDIF

         IF nMRow > 0 .AND. nMRow < MaxRow() - 1 .AND. nMCol > Int( MaxCol() / 2 )
            aPanelSelect := aPanelRight
            IF nMRow <= Len( aPanelSelect[ 6 ] )
               aPanelSelect[ 7 ] := nMRow
            ENDIF
         ENDIF

         nPos := aPanelSelect[ 7 ] + aPanelSelect[ 8 ]
         IF aPanelSelect[ 6 ][ nPos ][ 1 ] <> ".."


            IF aPanelSelect[ 6 ][ nPos ][ 6 ]
               aPanelSelect[ 6 ][ nPos ][ 6 ] := .F.
            ELSE

               aPanelSelect[ 6 ][ nPos ][ 6 ] := .T.
            ENDIF

         ENDIF

         PanelDisplay( aPanelLeft )
         PanelDisplay( aPanelRight )
         EXIT

      CASE 1002

         nMRow := MRow()
         nMCol := MCol()

         IF nMRow > 0 .AND. nMRow < MaxRow() - 1 .AND. nMCol < Int( MaxCol() / 2 ) + 1
            aPanelSelect := aPanelLeft
            IF nMRow <= Len( aPanelSelect[ 6 ] )
               aPanelSelect[ 7 ] := nMRow
            ENDIF
         ENDIF

         IF nMRow > 0 .AND. nMRow < MaxRow() - 1 .AND. nMCol > Int( MaxCol() / 2 )
            aPanelSelect := aPanelRight
            IF nMRow <= Len( aPanelSelect[ 6 ] )
               aPanelSelect[ 7 ] := nMRow
            ENDIF
         ENDIF


         nCol := Int( nMaxCol / 10 ) + 1
         IF nMRow > nMaxRow - 1
            SWITCH Int( MCol() / nCol ) + 1
            CASE 1  ; FunctionKey_F1() ; EXIT
            CASE 2  ; FunctionKey_F2() ; EXIT
            CASE 3  ; FunctionKey_F3( aPanelSelect ) ; EXIT
            CASE 4  ; FunctionKey_F4( aPanelSelect ) ; EXIT
            CASE 5  ; FunctionKey_F5( aPanelSelect ) ; EXIT
            CASE 6  ; FunctionKey_F6( aPanelSelect ) ; EXIT
            CASE 7  ; FunctionKey_F7( aPanelSelect ) ; EXIT
            CASE 8  ; FunctionKey_F8( aPanelSelect ) ; EXIT
            CASE 9  ; EXIT
            CASE 10
               IF HC_Alert( "The Harbour Commander", "Do you want to quit the Harbour Commander?", { "Yes", "No!" }, 0x8f ) == 1
                  lContinue := .F.
               ENDIF
               EXIT

            ENDSWITCH

         ENDIF

         PanelDisplay( aPanelLeft )
         PanelDisplay( aPanelRight )
         EXIT

      CASE 1014

         IF aPanelSelect[ 7 ] > 1
            --aPanelSelect[ 7 ]
         ELSE
            IF aPanelSelect[ 8 ] >= 1
               --aPanelSelect[ 8 ]
            ENDIF
         ENDIF

         EXIT

      CASE 1015

         IF aPanelSelect[ 7 ] < aPanelSelect[ 3 ] - 1 .AND. aPanelSelect[ 7 ] <= Len( aPanelSelect[ 6 ] ) - 1
            ++aPanelSelect[ 7 ]
         ELSE
            IF aPanelSelect[ 8 ] + aPanelSelect[ 7 ] <= Len( aPanelSelect[ 6 ] ) - 1
               ++aPanelSelect[ 8 ]
            ENDIF
         ENDIF

         EXIT

      CASE 5

         IF aPanelSelect[ 7 ] > 1
            --aPanelSelect[ 7 ]
         ELSE
            IF aPanelSelect[ 8 ] >= 1
               --aPanelSelect[ 8 ]
            ENDIF
         ENDIF

         EXIT

      CASE 24

         IF aPanelSelect[ 7 ] < aPanelSelect[ 3 ] - 1 .AND. aPanelSelect[ 7 ] <= Len( aPanelSelect[ 6 ] ) - 1
            ++aPanelSelect[ 7 ]
         ELSE
            IF aPanelSelect[ 8 ] + aPanelSelect[ 7 ] <= Len( aPanelSelect[ 6 ] ) - 1
               ++aPanelSelect[ 8 ]
            ENDIF
         ENDIF

         EXIT

      CASE 19

         IF aPanelSelect[ 10 ] > 0
            aPanelSelect[ 10 ]--
         ELSE
            IF aPanelSelect[ 11 ] >= 1
               aPanelSelect[ 11 ]--
            ENDIF
         ENDIF

         EXIT

      CASE 4

         IF aPanelSelect[ 10 ] < nMaxCol - Len( aPanelSelect[ 5 ] ) .AND. aPanelSelect[ 10 ] < Len( aPanelSelect[ 9 ] )
            aPanelSelect[ 10 ]++
         ELSE
            IF aPanelSelect[ 11 ] + aPanelSelect[ 10 ] < Len( aPanelSelect[ 9 ] )
               aPanelSelect[ 11 ]++
            ENDIF
         ENDIF

         EXIT

      CASE 1

         aPanelSelect[ 10 ] := 0

         EXIT

      CASE 6

         aPanelSelect[ 10 ] := Len( aPanelSelect[ 9 ] )

         EXIT

      CASE 18

         IF aPanelSelect[ 7 ] <= 1
            IF aPanelSelect[ 8 ] - nMaxRow >= 0
               aPanelSelect[ 8 ] -= nMaxRow
            ENDIF
         ENDIF

         aPanelSelect[ 7 ] := 1
         EXIT

      CASE 3

         IF aPanelSelect[ 7 ] >= nMaxRow - 3
            IF aPanelSelect[ 8 ] + nMaxRow  <= Len( aPanelSelect[ 6 ] )
               aPanelSelect[ 8 ] += nMaxRow
            ENDIF
         ENDIF

         aPanelSelect[ 7 ] := Min( nMaxRow - 3, Len( aPanelSelect[ 6 ] ) - aPanelSelect[ 8 ] )
         EXIT

      CASE 22

         nPos := aPanelSelect[ 7 ] + aPanelSelect[ 8 ]
         IF aPanelSelect[ 6 ][ nPos ][ 1 ] <> ".."


            IF aPanelSelect[ 6 ][ nPos ][ 6 ]
               aPanelSelect[ 6 ][ nPos ][ 6 ] := .F.
            ELSE

               aPanelSelect[ 6 ][ nPos ][ 6 ] := .T.
            ENDIF

            IF aPanelSelect[ 7 ] < aPanelSelect[ 3 ] - 1 .AND. aPanelSelect[ 7 ] <= Len( aPanelSelect[ 6 ] ) - 1
               ++aPanelSelect[ 7 ]
            ELSE
               IF aPanelSelect[ 8 ] + aPanelSelect[ 7 ] <= Len( aPanelSelect[ 6 ] ) - 1
                  ++aPanelSelect[ 8 ]
               ENDIF
            ENDIF

         ENDIF

         EXIT

      CASE 7

         IF aPanelSelect[ 10 ] >= 0
            aPanelSelect[ 9 ] := Stuff( aPanelSelect[ 9 ], aPanelSelect[ 10 ] + 1, 1, "" )
         ENDIF

         EXIT

      CASE 8

         IF aPanelSelect[ 10 ] > 0
            aPanelSelect[ 9 ] := Stuff( aPanelSelect[ 9 ], aPanelSelect[ 10 ], 1, "" )
            aPanelSelect[ 10 ]--
         ENDIF

         EXIT

      CASE 28

         FunctionKey_F1()

         EXIT

      CASE -1

         FunctionKey_F2()

         EXIT

      CASE -2

         FunctionKey_F3( aPanelSelect )

         EXIT

      CASE -3

         FunctionKey_F4( aPanelSelect )

         EXIT

      CASE -4

         FunctionKey_F5( aPanelSelect )

         EXIT

      CASE -5

         FunctionKey_F6( aPanelSelect )

         EXIT

      CASE -6

         FunctionKey_F7( aPanelSelect )

         EXIT

      CASE -7

         FunctionKey_F8( aPanelSelect )

         EXIT

      CASE -8

         FunctionKey_F9( )

         EXIT

      CASE -9
         lContinue := .F.
         EXIT



      CASE -30




         IF ( cNewDrive := HC_Alert( "Drive letter", "Choose left drive:", AllDrives(), 0x8a, 0x0 ) ) <> 0

               hb_CurDrive( AllDrives()[ cNewDrive ] )
               PanelFetchList( aPanelLeft, hb_cwd() )
               PanelDisplay( aPanelLeft )

         ENDIF

         EXIT

      CASE -31



         IF ( cNewDrive := HC_Alert( "Drive letter", "Choose right drive:", AllDrives(), 0x8a, 0x1 ) ) <> 0

            hb_CurDrive( AllDrives()[ cNewDrive ] )
            PanelFetchList( aPanelRight, hb_cwd() )
            PanelDisplay( aPanelRight )

         ENDIF

         EXIT


      CASE -13

         nPos := aPanelSelect[ 7 ] + aPanelSelect[ 8 ]

         IF At( "D", aPanelSelect[ 6 ][ nPos ][ 5 ] ) == 0

            IF HB_ISSTRING( cFileName := MsgBox( "Create file.", aPanelSelect[ 5 ] + aPanelSelect[ 6 ][ nPos ][ 1 ], { "Yes", "No!" } ) )
               IF hb_vfExists( cFileName )

                  HCEdit( cFileName, .T. )

               ELSE
                  IF ( pHandle := hb_vfOpen( cFileName, 0x0100 + 0x0200 + 1 ) ) <> NIL

                     IF ! hb_vfClose( pHandle )
                        IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                           HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + FileError()[ nErrorCode ][ 2 ] )
                        ELSE
                           HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + hb_ntos( FError() ) )
                        ENDIF
                     ENDIF

                     PanelRefresh( aPanelSelect )

                  ELSE

                     IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + FileError()[ nErrorCode ][ 2 ] )
                     ELSE
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + hb_ntos( FError() ) )
                     ENDIF

                  ENDIF
               ENDIF

            ENDIF

         ELSE

            IF HB_ISSTRING( cFileName := MsgBox( "Create file.", NIL, { "Yes", "No!" } ) )
               IF ( pHandle := hb_vfOpen( aPanelSelect[ 5 ] + cFileName, 0x0100 + 0x0200 + 1 ) ) <> NIL

                  IF ! hb_vfClose( pHandle )
                     IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + FileError()[ nErrorCode ][ 2 ] )
                     ELSE
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + hb_ntos( FError() ) )
                     ENDIF
                  ENDIF

                  PanelRefresh( aPanelSelect, cFileName )

               ELSE

                  IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                     HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + FileError()[ nErrorCode ][ 2 ] )
                  ELSE
                     HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + hb_ntos( FError() ) )
                  ENDIF

               ENDIF
            ENDIF

         ENDIF

         EXIT

      CASE 43
         FOR i := 1 TO Len( aPanelSelect[ 6 ] )
            IF aPanelSelect[ 6 ][ i ][ 1 ] <> ".."
               aPanelSelect[ 6 ][ i ][ 6 ] := .F.
            ENDIF
         NEXT
         EXIT

      CASE 95
         FOR i := 1 TO Len( aPanelSelect[ 6 ] )
            IF aPanelSelect[ 6 ][ i ][ 1 ] <> ".."
               aPanelSelect[ 6 ][ i ][ 6 ] := .T.
            ENDIF
         NEXT
         EXIT

      OTHERWISE

         IF ( nKeyStd >= 32 .AND. nKeyStd <= 126 ) .OR. ( nKeyStd >= 160 .AND. nKeyStd <= 255 ) .OR. ! hb_keyChar( nKeyStd ) == ""

            aPanelSelect[ 9 ] := Stuff( aPanelSelect[ 9 ], aPanelSelect[ 10 ] + aPanelSelect[ 11 ] + 1, 0, hb_keyChar( nKeyStd ) )
            IF aPanelSelect[ 10 ] < nMaxCol - Len( aPanelSelect[ 5 ] )
               aPanelSelect[ 10 ]++
            ELSE
               aPanelSelect[ 11 ]++
            ENDIF

         ENDIF

      ENDSWITCH

   ENDDO

   RETURN

STATIC PROCEDURE FunctionKey_F1()









   IF HC_Alert( "Report an error",  "Creating an issue;" +  ";Issues can be used to keep track of bugs, enhancements, or;" +  "other requests.;" +  ";Any GitHub user can create an issue in a public repository;" +  "where issues have not been disabled.;" +  ";You can open a new issue based on code from an existing pull;" +  "request.;",  { "Click New issue." } ) == 1


      hb_run( "start " + "https://github.com/rjopek/harbour-commander/issues/new" )




   ENDIF

   RETURN

STATIC PROCEDURE FunctionKey_F2()

   HC_MenuF2()

   RETURN

STATIC PROCEDURE FunctionKey_F3( aPanel )

   LOCAL nPos
   LOCAL aTarget := {}, aItem, aDirScan
   LOCAL nLengthName := 0

   nPos := aPanel[ 7 ] + aPanel[ 8 ]

   IF At( "D", aPanel[ 6 ][ nPos ][ 5 ] ) == 0

      HCEdit( aPanel[ 5 ] + aPanel[ 6 ][ nPos ][ 1 ], .F. )

   ELSE
      aDirScan := hb_DirScan( aPanel[ 6 ][ nPos ][ 1 ], hb_osFileMask() )
      AScan( aDirScan, {| x | nLengthName := Max( nLengthName, Len( x[ 1 ] ) ) } )

      FOR EACH aItem IN aDirScan




         AAdd( aTarget,  PadR( aItem[ 1 ], nLengthName ) + " " +  Transform( hb_ntos( aItem[ 2 ] ), "9 999 999 999" ) + " " +  hb_TToC( aItem[ 3 ] ) + " " +  aItem[ 5 ] )
      NEXT

      SaveFile( aTarget, "DirScan.txt" )

      HCEdit( "DirScan.txt", .F. )
   ENDIF

   RETURN

STATIC PROCEDURE FunctionKey_F4( aPanel )

   LOCAL nPos

   nPos := aPanel[ 7 ] + aPanel[ 8 ]

   IF At( "D", aPanel[ 6 ][ nPos ][ 5 ] ) == 0
      HCEdit( aPanel[ 5 ] + aPanel[ 6 ][ nPos ][ 1 ], .T. )
   ELSE
      HC_Alert( "No file selected", "Select the file to edit",, 0x8f )
   ENDIF

   RETURN

STATIC PROCEDURE FunctionKey_F5( aPanel )

   LOCAL nPos
   LOCAL nErrorCode

   nPos := aPanel[ 7 ] + aPanel[ 8 ]
   IF aPanel[ 6 ][ nPos ][ 1 ] == ".."
      HC_Alert( "Copy", "The item to be copy has not been selected.",, 0x8f )
   ELSE

      IF aPanel == aPanelLeft

         IF At( "D", aPanel[ 6 ][ nPos ][ 5 ] ) == 0

            IF HB_ISSTRING( MsgBox( "Copy file " + '"' + aPanelLeft[ 6 ][ nPos ][ 1 ] + '"' + " to",  aPanelRight[ 5 ] + aPanelLeft[ 6 ][ nPos ][ 1 ], { "Yes", "No!" } ) )



               IF HC_CopyFile( aPanelLeft[ 5 ] + aPanelLeft[ 6 ][ nPos ][ 1 ],  aPanelRight[ 5 ] + aPanelLeft[ 6 ][ nPos ][ 1 ] ) == 0

                  PanelRefresh( aPanelRight )

               ELSE
                  IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                     HC_Alert( "Error", "Test for errors after a binary file operation.;The file can not be copied;" + FileError()[ nErrorCode ][ 2 ] )

                  ELSE
                     HC_Alert( "Error", "Test for errors after a binary file operation.;The file can not be copied;" + hb_ntos( FError() ) )
                  ENDIF
               ENDIF

            ENDIF
         ELSE

            IF HB_ISSTRING( MsgBox( "Copy directory " + '"' + aPanelLeft[ 6 ][ nPos ][ 1 ] + '"' + " to",  aPanelRight[ 5 ], { "Yes", "No!" } ) )


               IF HC_CopyDirectory( aPanelLeft[ 5 ] + aPanelLeft[ 6 ][ nPos ][ 1 ],  aPanelRight[ 5 ] ) == 0

                  PanelRefresh( aPanelRight )

               ELSE
                  IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                     HC_Alert( "Error", "Test for errors after a binary file operation.;The directory can not be copied;" + FileError()[ nErrorCode ][ 2 ] )
                  ELSE
                     HC_Alert( "Error", "Test for errors after a binary file operation.;The directory can not be copied;" + hb_ntos( FError() ) )
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ELSE

         IF At( "D", aPanel[ 6 ][ nPos ][ 5 ] ) == 0

            IF HB_ISSTRING( MsgBox( "Copy file " + '"' + aPanelRight[ 6 ][ nPos ][ 1 ] + '"' + " to",  aPanelLeft[ 5 ] + aPanelRight[ 6 ][ nPos ][ 1 ], { "Yes", "No!" } ) )


               IF HC_CopyFile( aPanelRight[ 5 ] + aPanelRight[ 6 ][ nPos ][ 1 ],  aPanelLeft[ 5 ] + aPanelRight[ 6 ][ nPos ][ 1 ] ) == 0

                  PanelRefresh( aPanelLeft )

               ELSE
                  IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                     HC_Alert( "Error", "Test for errors after a binary file operation.;The file can not be copied;" + FileError()[ nErrorCode ][ 2 ] )
                  ELSE
                     HC_Alert( "Error", "Test for errors after a binary file operation.;The file can not be copied;" + hb_ntos( FError() ) )
                  ENDIF
               ENDIF
            ENDIF
         ELSE

            IF HB_ISSTRING( MsgBox( "Copy directory " + '"' + aPanelRight[ 6 ][ nPos ][ 1 ] + '"' + " to",  aPanelLeft[ 5 ], { "Yes", "No!" } ) )


               IF HC_CopyDirectory( aPanelRight[ 5 ] + aPanelRight[ 6 ][ nPos ][ 1 ],  aPanelLeft[ 5 ] ) == 0

                  PanelRefresh( aPanelLeft )

               ELSE
                  IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                     HC_Alert( "Error", "Test for errors after a binary file operation.;The directory can not be copied;" + FileError()[ nErrorCode ][ 2 ] )
                  ELSE
                     HC_Alert( "Error", "Test for errors after a binary file operation.;The directory can not be copied;" + hb_ntos( FError() ) )
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDIF

   RETURN

STATIC PROCEDURE FunctionKey_F6( aPanel )

   LOCAL nPos
   LOCAL nErrorCode

   nPos := aPanel[ 7 ] + aPanel[ 8 ]
   IF aPanel[ 6 ][ nPos ][ 1 ] == ".."
      HC_Alert( "Rename or move", "The item to be copy has not been selected.",, 0x8f )
   ELSE

      IF aPanel == aPanelLeft

         IF At( "D", aPanel[ 6 ][ nPos ][ 5 ] ) == 0

            IF HB_ISSTRING( MsgBox( "Move file " + '"' + aPanelLeft[ 6 ][ nPos ][ 1 ] + '"' + " to",  aPanelRight[ 5 ], { "Yes", "No!" } ) )


               IF HC_CopyFile( aPanelLeft[ 5 ] + aPanelLeft[ 6 ][ nPos ][ 1 ],  aPanelRight[ 5 ] + aPanelLeft[ 6 ][ nPos ][ 1 ] ) == 0

                  PanelRefresh( aPanelRight )

                  IF hb_DirRemoveAll( aPanelLeft[ 5 ] + aPanelLeft[ 6 ][ nPos ][ 1 ] ) == .T.

                     PanelRefresh( aPanelLeft )

                  ELSE
                     IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + FileError()[ nErrorCode ][ 2 ] )
                     ELSE
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + hb_ntos( FError() ) )
                     ENDIF
                  ENDIF

               ELSE
                  IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                     HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + FileError()[ nErrorCode ][ 2 ] )
                  ELSE
                     HC_Alert( "Error", "Test for errors after a binary file operation.;annot make file, error:;" + hb_ntos( FError() ) )
                  ENDIF
               ENDIF

            ENDIF
         ELSE

            IF HB_ISSTRING( MsgBox( "Move directory " + '"' + aPanelLeft[ 6 ][ nPos ][ 1 ] + '"' + " to",  aPanelRight[ 5 ], { "Yes", "No!" } ) )


               IF HC_CopyDirectory( aPanelLeft[ 5 ] + aPanelLeft[ 6 ][ nPos ][ 1 ],  aPanelRight[ 5 ] ) == 0

                  PanelRefresh( aPanelRight )

                  IF hb_DirRemoveAll( aPanelLeft[ 5 ] + aPanelLeft[ 6 ][ nPos ][ 1 ] ) == .T.

                     PanelRefresh( aPanelLeft )

                  ELSE
                     IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make directory, error:;" + FileError()[ nErrorCode ][ 2 ] )
                     ELSE
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make directory, error:;" + hb_ntos( FError() ) )
                     ENDIF
                  ENDIF

               ELSE
                  IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                     HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make directory, error:;" + FileError()[ nErrorCode ][ 2 ] )
                  ELSE
                     HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make directory, error:;" + hb_ntos( FError() ) )
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ELSE

         IF At( "D", aPanel[ 6 ][ nPos ][ 5 ] ) == 0

            IF HB_ISSTRING( MsgBox( "Move file " + '"' + aPanelRight[ 6 ][ nPos ][ 1 ] + '"' + " to",  aPanelLeft[ 5 ], { "Yes", "No!" } ) )


               IF HC_CopyFile( aPanelRight[ 5 ] + aPanelRight[ 6 ][ nPos ][ 1 ],  aPanelLeft[ 5 ] + aPanelRight[ 6 ][ nPos ][ 1 ] ) == 0

                  PanelRefresh( aPanelLeft )

                  IF hb_DirRemoveAll( aPanelRight[ 5 ] + aPanelRight[ 6 ][ nPos ][ 1 ] ) == .T.

                     PanelRefresh( aPanelRight )

                  ELSE
                     IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + FileError()[ nErrorCode ][ 2 ] )
                     ELSE
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + hb_ntos( FError() ) )
                     ENDIF
                  ENDIF

               ELSE
                  IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                     HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + FileError()[ nErrorCode ][ 2 ] )
                  ELSE
                     HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + hb_ntos( FError() ) )
                  ENDIF
               ENDIF
            ENDIF
         ELSE

            IF HB_ISSTRING( MsgBox( "Move directory " + '"' + aPanelRight[ 6 ][ nPos ][ 1 ] + '"' + " to",  aPanelLeft[ 5 ], { "Yes", "No!" } ) )


               IF HC_CopyDirectory( aPanelRight[ 5 ] + aPanelRight[ 6 ][ nPos ][ 1 ],  aPanelLeft[ 5 ] ) == 0

                  PanelRefresh( aPanelLeft )

                  IF hb_DirRemoveAll( aPanelRight[ 5 ] + aPanelRight[ 6 ][ nPos ][ 1 ] ) == .T.

                     PanelRefresh( aPanelRight )

                  ELSE
                     IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make directory, error:;" + FileError()[ nErrorCode ][ 2 ] )
                     ELSE
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make directory, error:;" + hb_ntos( FError() ) )
                     ENDIF
                  ENDIF

               ELSE
                  IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                     HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make directory, error:;" + FileError()[ nErrorCode ][ 2 ] )
                  ELSE
                     HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make directory, error:;" + hb_ntos( FError() ) )
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDIF






   RETURN

STATIC PROCEDURE FunctionKey_F7( aPanel )

   LOCAL cNewDir
   LOCAL nErrorCode

   IF HB_ISSTRING( cNewDir := MsgBox( "Create the directory.", NIL, { "Yes", "No!" } ) )

      IF hb_vfDirMake( aPanel[ 5 ] + cNewDir ) == 0

         PanelRefresh( aPanel, cNewDir )

      ELSE
         IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
            HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make directory, error:;" + FileError()[ nErrorCode ][ 2 ] )
         ELSE
            HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make directory, error:;" + hb_ntos( FError() ) )
         ENDIF
      ENDIF
   ENDIF

   RETURN

STATIC PROCEDURE FunctionKey_F8( aPanel )

   LOCAL nPos
   LOCAL nErrorCode

   nPos := aPanel[ 7 ] + aPanel[ 8 ]

   IF aPanel[ 6 ][ nPos ][ 1 ] == ".."
      HC_Alert( "Up Directory", "The item to be deleted has not been selected." )
   ELSE
      nPos := aPanel[ 7 ] + aPanel[ 8 ]

      IF At( "D", aPanel[ 6 ][ nPos ][ 5 ] ) == 0


         IF aPanelSelect[ 6 ][ nPos ][ 6 ]
            aPanelSelect[ 6 ][ nPos ][ 6 ] := .F.
         ENDIF

         PanelDisplay( aPanel )

         IF HC_Alert( "Delete file", "Do you really want to delete the selected file:;" + '"' + aPanel[ 6 ][ nPos ][ 1 ] + '"', { "Yes", "No!" } ) == 1


            IF HC_DeleteFile( aPanelSelect ) == 0

               PanelRefresh( aPanel )

            ELSE
               IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                  HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + FileError()[ nErrorCode ][ 2 ] )
               ELSE
                  HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make file, error:;" + hb_ntos( FError() ) )
               ENDIF
            ENDIF
         ELSE

            aPanelSelect[ 6 ][ nPos ][ 6 ] := .T.
         ENDIF

      ELSE

         IF HC_Alert( "Down Directory", "Do you really want to delete the selected directory:;" + '"' + aPanel[ 6 ][ nPos ][ 1 ] + '"', { "Yes", "No!" }, 0x9f ) == 1
            IF hb_vfDirRemove( aPanel[ 5 ] + aPanel[ 6 ][ nPos ][ 1 ] ) == 0

               PanelRefresh( aPanel )

            ELSE


               IF HC_Alert( "Down Directory", "The following subdirectory is not empty. ;" +  '"' + aPanel[ 6 ][ nPos ][ 1 ] + '"' + ";" +  "Do you still wish to delete it?", { "Delete", "No!" } ) == 1

                  IF hb_DirRemoveAll( aPanel[ 5 ] + aPanel[ 6 ][ nPos ][ 1 ] ) == .T.

                     PanelRefresh( aPanel )

                  ELSE
                     IF ( nErrorCode := AScan( FileError(), {| x | x[ 1 ] == FError() } ) ) > 0
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make directory, error:;" + FileError()[ nErrorCode ][ 2 ] )
                     ELSE
                        HC_Alert( "Error", "Test for errors after a binary file operation.;Cannot make directory, error:;" + hb_ntos( FError() ) )
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   ENDIF







   RETURN

STATIC PROCEDURE FunctionKey_F9( )

   LOCAL nTop, nLeft, nRight
   LOCAL cScreen, cScreenSub
   LOCAL nKey, nKeyStd
   LOCAL lReDraw := .T.
   LOCAL lContinue := .T.
   LOCAL i
   LOCAL iMenu := 1
   LOCAL aF9Menu := { "Left", "Option", "Right" }
   LOCAL aF9MenuPos := { 1 }
   LOCAL aF9SubMenu := { "Option" => { "Panel settings", "Save settings" } }
   LOCAL nResult
   LOCAL nBottomSub
   LOCAL nLeftSub

   nTop := 0
   nLeft := 0
   nRight := MaxCol()

   aEval( aF9Menu, {| x, y | Aadd( aF9MenuPos, aF9MenuPos[ y ] + Len( x ) + 1 ) },, Len( aF9Menu ) - 1 )

   cScreen := SaveScreen( nTop, nLeft, nTop, nRight )

   hb_DispBox( nTop, nLeft, nTop, nRight, hb_UTF8ToStrBox( " █       " ), 0x22 )

   while lContinue
      IF lReDraw
         DispBegin()
         FOR EACH i IN aF9Menu
            hb_DispOutAt( nTop, aF9MenuPos[ i:__enumIndex ], i, iif( i:__enumIndex == iMenu, 0x8f, 0x20 ) )
         NEXT
         DispEnd()
         lReDraw := .F.
      ENDIF

      nKey := Inkey( 0 )
      nKeyStd := hb_keyStd( nKey )

      SWITCH nKeyStd
      CASE 27
         lContinue := .F.
         EXIT

      CASE 19
         iMenu --
         IF iMenu < 1
            iMenu := Len( aF9Menu )
         ENDIF
         lReDraw := .T.
         EXIT

      CASE 4
         iMEnu ++
         IF iMenu > Len( aF9Menu )
            iMenu := 1
         ENDIF
         lReDraw := .T.
         EXIT

      CASE 13
         IF HB_HHasKey( aF9SubMenu, aF9Menu[ iMenu ] )
            nLeftSub := 0
            nBottomSub := Min( nTop + 1 + Len( aF9SubMenu[ aF9Menu[ iMenu ] ] ) + 1, MaxRow() )
            aEval( aF9SubMenu[ aF9Menu[ iMenu ] ], {| x | nLeftSub := Max( Len( x ), nLeftSub ) } )
            nLeftSub := Min( aF9MenuPos[ iMenu ] + nLeftSub + 1, MaxCol() )
            cScreenSub := SaveScreen( nTop + 1, aF9MenuPos[ iMenu ], nBottomSub, nLeftSub )
            hb_DispBox( nTop + 1, aF9MenuPos[ iMenu ], nBottomSub, nLeftSub, hb_UTF8ToStrBox( "╔═╗║╝═╚║" ) + " ", 0x8a )
            nResult := Achoice( nTop + 2, aF9MenuPos[ iMenu ] + 1, nBottomSub -1, nLeftSub - 1, aF9SubMenu[ aF9Menu[ iMenu ] ] )
            if nResult > 0
               HC_ALERT( "SubMenu", "Your choice is '" + aF9SubMenu[ aF9Menu[ iMenu ] ][ nResult ] + "'" )
            endif
            RestScreen( nTop + 1, aF9MenuPos[ iMenu ], nBottomSub, nLeftSub, cScreenSub )
         ELSE
            HC_ALERT( "Warning", "Not implemented yet",, 0x8f )
         ENDIF
         EXIT
      ENDSWITCH

   ENDDO

   RestScreen( nTop, nLeft, nTop, nRight, cScreen )

   RETURN




STATIC FUNCTION HC_CopyFile( cSourceFile, cTargetFile )

   LOCAL nRow, nCol
   LOCAL nWidth
   LOCAL nTop, nLeft, nBottom, nRight
   LOCAL cScreen
   LOCAL nReturn := 0
   LOCAL nMaxRow := MaxRow(), nMaxCol := MaxCol()
   LOCAL pSource
   LOCAL pTarget
   LOCAL nPosition
   LOCAL nBufferSize := 65536
   LOCAL cBuffer
   LOCAL tsDateTime
   LOCAL nFileSize

   nWidth := Max( Len( cSourceFile ), Len( cTargetFile ) ) + 2

   nRow := Int( nMaxRow / 3 )
   nCol := Int( ( nMaxCol - nWidth ) / 2 )

   nTop    := nRow
   nLeft   := nCol - 1
   nBottom := nRow + 7
   nRight  := nCol + nWidth

   cScreen := SaveScreen( nTop, nLeft, nBottom + 1, nRight + 2 )
   hb_DispBox( nTop, nLeft, nBottom, nRight, hb_UTF8ToStrBox( "╔═╗║╝═╚║" ) + " ", 0x8f )
   hb_Shadow( nTop, nLeft, nBottom, nRight )

   cBuffer := Space( nBufferSize )


   IF ( pSource := hb_vfOpen( cSourceFile, 0 + 64 + 0x4000 ) ) <> NIL


      IF ( pTarget := hb_vfOpen( cTargetFile, 0x0100 + 1 + 16 + 0x4000 ) ) <> NIL

         hb_DispOutAt( ++nRow, nCol, PadC( "Copying the file", nWidth ), 0x8f )
         hb_DispOutAt( ++nRow, nCol, PadC( cSourceFile, nWidth ), 0x8f )
         hb_DispOutAt( ++nRow, nCol, PadC( "to", nWidth ), 0x8f )
         hb_DispOutAt( ++nRow, nCol, PadC( cTargetFile, nWidth ), 0x8f )


         nPosition := hb_vfSeek( pSource, 0, 2 )
         nFileSize := nPosition

         hb_vfSeek( pSource, 0 )

         while ( nPosition > 0 )

            IF nPosition < nBufferSize
               nBufferSize := nPosition
            ENDIF

            IF nBufferSize <> hb_vfRead( pSource, @cBuffer, nBufferSize )
               nReturn := FError()
               EXIT
            ENDIF
            IF nBufferSize <> hb_vfWrite( pTarget, @cBuffer, nBufferSize )
               nReturn := FError()
               EXIT
            ENDIF

            nPosition -= nBufferSize

            DispBegin()
            hb_DispOutAt( ++nRow, nCol, PadC( hb_ntos( 100 * ( nFileSize - nPosition ) / nFileSize ) + " %", nWidth ), 0x8a )

            hb_DispOutAt( ++nRow, nCol, Replicate( " ", nWidth ), 0x0 )
            hb_DispOutAt(   nRow, nCol, Replicate( " ", nWidth * ( nFileSize - nPosition ) / nFileSize ), 0x22 )

            DispEnd()
            nRow := Int( nMaxRow / 3 ) + 4

         ENDDO

         hb_vfClose( pTarget )
         hb_vfClose( pSource )


         hb_vfTimeGet( cSourceFile, @tsDateTime )
         hb_vfTimeSet( cTargetFile, tsDateTime )

      ELSE

         hb_vfClose( pSource )
         nReturn := FError()

      ENDIF
   ENDIF

   RestScreen( nTop, nLeft, nBottom + 1, nRight + 2, cScreen )

   RETURN nReturn

STATIC FUNCTION HC_CopyDirectory( cSourceFile, cTargetFile )

   LOCAL aCatalog
   LOCAL nRows
   LOCAL i
   LOCAL cSubCat

   cSubCat := hb_FNameNameExt( cSourceFile )
   IF hb_DirCreate( cTargetFile + cSubCat ) <> 0
      RETURN FError()
   ENDIF

   aCatalog := hb_vfDirectory( cSourceFile + hb_ps(), "HSD" )
   nRows    := Len( aCatalog )

   FOR i := 1 TO nRows
      IF aCatalog[ i ][ 1 ] == "." .OR. aCatalog[ i ][ 1 ] == ".."

      ELSEIF "D" $ aCatalog[ i ][ 5 ]
         IF HC_CopyDirectory( cSourceFile + hb_ps() + aCatalog[ i ][ 1 ], cTargetFile + cSubCat + hb_ps() ) == -1
            RETURN FError()
         ENDIF
      ELSE

         IF HC_CopyFile( cSourceFile + hb_ps() + aCatalog[ i ][ 1 ], cTargetFile + cSubCat + hb_ps() + aCatalog[ i ][ 1 ] ) <> 0
            RETURN FError()
         ENDIF

      ENDIF

   NEXT

   RETURN 0

STATIC FUNCTION HC_DeleteFile( aPanel )

   LOCAL i

   FOR i := 1 TO Len( aPanel[ 6 ] )

      IF aPanel[ 6 ][ i ][ 6 ] == .F.

         while hb_vfErase( aPanel[ 5 ] + aPanel[ 6 ][ i ][ 1 ] ) == -1
            RETURN FError()
         ENDDO



         aPanel[ 7 ] -= 1


      ENDIF

   NEXT

   RETURN 0

STATIC PROCEDURE PanelDisplay( aPanel )

   LOCAL nRow, nPos := 1
   LOCAL nLengthName := 4
   LOCAL nLengthSize := 0



   AScan( aPanel[ 6 ], {| x |  nLengthName := Max( nLengthName, Len( x[ 1 ] ) ),  nLengthSize := Max( nLengthSize, Len( Str( x[ 2 ] ) ) ) } )

   DispBegin()


   hb_DispBox( aPanel[ 1 ], aPanel[ 2 ], aPanel[ 3 ], aPanel[ 4 ], iif( aPanelSelect == aPanel, hb_UTF8ToStrBox( "╔═╗║╝═╚║" ), hb_UTF8ToStrBox( "┌─┐│┘─└│" ) ) + " ", 0x1f )

   nPos += aPanel[ 8 ]
   FOR nRow := aPanel[ 1 ] + 1 TO aPanel[ 3 ] - 1

      IF nPos <= Len( aPanel[ 6 ] )









         hb_DispOutAt( nRow, aPanel[ 2 ] + 1,  PadR( Expression( nLengthName, nLengthSize,  aPanel[ 6 ][ nPos ][ 1 ],  aPanel[ 6 ][ nPos ][ 2 ],  aPanel[ 6 ][ nPos ][ 3 ],  aPanel[ 6 ][ nPos ][ 5 ] ),  aPanel[ 4 ] - aPanel[ 2 ] - 1 ),  iif( aPanelSelect == aPanel .AND. nPos == aPanel[ 7 ] + aPanel[ 8 ],  iif( ! aPanel[ 6 ][ nPos ][ 6 ], 0x3e, 0x30 ),  ColoringSyntax( aPanel[ 6 ][ nPos ][ 5 ], aPanel[ 6 ][ nPos ][ 6 ] ) ) )
         ++nPos
      ELSE
         EXIT
      ENDIF

   NEXT

   PanelTitleDisplay( aPanel )

   DispEnd()

   RETURN

STATIC PROCEDURE ComdLineDisplay( aPanel )

   LOCAL nMaxRow := MaxRow(), nMaxCol := MaxCol()

   DispBegin()


   hb_DispOutAt( nMaxRow - 1, 0,  PadR( aPanel[ 5 ] + SubStr( aPanel[ 9 ], 1 + aPanel[ 11 ], nMaxCol + aPanel[ 11 ] ), nMaxCol ), 0x7 )

   SetPos( nMaxRow - 1, aPanel[ 10 ] + Len( aPanel[ 5 ] ) )

   DispEnd()

   RETURN


STATIC PROCEDURE PanelTitleDisplay( aPanel )

   LOCAL cPanelTitle := aPanel[ 5 ]
   LOCAL nWidthPanel

   nWidthPanel := aPanel[ 4 ] - aPanel[ 2 ] - 2
   IF Len( cPanelTitle ) < nWidthPanel
      cPanelTitle := PadR( aPanel[ 5 ], Min( Len( aPanel[ 5 ] ), nWidthPanel ), Space( 0 ) )
   ELSE
      cPanelTitle := SubStr( cPanelTitle, 1, 3 ) + "..." + Right( cPanelTitle, nWidthPanel - 5 )
   ENDIF

   DispBegin()

   hb_DispOutAt( aPanel[ 1 ], aPanel[ 2 ] + 1, cPanelTitle, 0x1f )

   DispEnd()

   RETURN

STATIC FUNCTION Expression( nLengthName, nLengthSize, cName, cSize, dDate, cAttr )

   LOCAL cFileName, cFileSize, dFileDate, cFileAttr

   cFileName := PadR( cName + Space( nLengthName ), nLengthName ) + " "

   IF cName == ".."
      cFileName := PadR( "[" + AllTrim( cFileName ) + "]" + Space( nLengthName ), nLengthName ) + " "
   ENDIF

   IF cAttr == "D" .OR. cAttr == "HD" .OR. cAttr == "HSD" .OR. cAttr == "HSDL" .OR. cAttr == "RHSA" .OR. cAttr == "RD" .OR. cAttr == "AD" .OR. cAttr == "RHD"
      cFileSize := PadL( Iif( rTrim( cFileName ) == "[..]", "UP--DIR", "DIR"), nLengthSize + 3 ) + " "
   ELSE
      cFileSize := PadL( Transform( cSize, "9 999 999 999" ), nLengthSize + 3 ) + " "
   ENDIF

   dFileDate := hb_TToC( dDate ) + " "
   cFileAttr := PadL( cAttr, 3 )

   RETURN cFileName + cFileSize + dFileDate + cFileAttr

STATIC FUNCTION ColoringSyntax( cAttr, lStatus )

   LOCAL nColor

   IF cAttr == "HD" .OR. cAttr == "HSD" .OR. cAttr == "HSDL" .OR. cAttr == "RHSA" .OR. cAttr == "RD"
      nColor := 0x13
   ELSE
      nColor := 0x1f
   ENDIF

   IF ! lStatus
      nColor := 0x1e
   ENDIF

   RETURN nColor

STATIC PROCEDURE PanelRefresh( aPanel, nRowBar2cDir )

   LOCAL _nRowBarNew

   IF aPanelLeft[ 5 ] == aPanelRight[ 5 ]

      PanelFetchList( aPanelLeft, aPanelLeft[ 5 ] )
      PanelFetchList( aPanelRight, aPanelRight[ 5 ] )

      IF HB_ISSTRING( nRowBar2cDir )
         _nRowBarNew := GetRowBarPos( aPanelLeft, nRowBar2cDir )
         aPanelLeft[ 7 ] := _nRowBarNew
         aPanelRight[ 7 ] := _nRowBarNew
      ENDIF

      PanelDisplay( aPanelLeft )
      PanelDisplay( aPanelRight )

   ELSE

      PanelFetchList( aPanel, aPanel[ 5 ] )

      IF HB_ISSTRING( nRowBar2cDir )
         _nRowBarNew := GetRowBarPos( aPanel, nRowBar2cDir )
         aPanel[ 7 ] := _nRowBarNew
      ENDIF

      PanelDisplay( aPanel )

   ENDIF

   RETURN

STATIC FUNCTION GetRowBarPos( aPanel, nRowBar2cDir )

   LOCAL nPos

   nPos := Ascan( aPanel[ 6 ], {| x | x[ 1 ] == nRowBar2cDir } )

   RETURN iif( nPos == 0, 1, nPos )

STATIC PROCEDURE ChangeDir( aPanel )

   LOCAL nPos, cDir, cDir0
   LOCAL nPosLast

   nPos := aPanel[ 7 ] + aPanel[ 8 ]
   IF At( "D", aPanel[ 6 ][ nPos ][ 5 ] ) == 0
      RETURN
   ENDIF
   IF aPanel[ 6 ][ nPos ][ 1 ] == ".."
      cDir := aPanel[ 5 ]
      cDir0 := SubStr( cDir, RAt( hb_ps(), Left( cDir, Len( cDir ) - 1 ) ) + 1 )
      cDir0 := SubStr( cDir0, 1, Len( cDir0 ) - 1 )
      cDir  := Left( cDir, RAt( hb_ps(), Left( cDir, Len( cDir ) - 1 ) ) )
      PanelFetchList( aPanel, cDir )
      nPosLast := Max( AScan( aPanel[ 6 ], {| x | x[ 1 ] == cDir0 } ), 1 )

      IF nPosLast > aPanelSelect[ 3 ] - 1
         aPanelSelect[ 8 ] := nPosLast % ( aPanelSelect[ 3 ] - 1 )
         aPanelSelect[ 7 ] := aPanelSelect[ 3 ] - 1
      ELSE
         aPanelSelect[ 8 ]  := 0
         aPanelSelect[ 7 ] := nPosLast
      ENDIF

   ELSE
      cDir := aPanel[ 5 ] + aPanel[ 6 ][ nPos ][ 1 ] + hb_ps()
      aPanel[ 7 ] := 1
      aPanel[ 8  ] := 0
      PanelFetchList( aPanel, cDir )
   ENDIF

   RETURN

STATIC FUNCTION AllDrives()

   LOCAL i
   LOCAL aArrayDrives := {}

   FOR i := 1 TO 26
      IF DiskChange( Chr( i + 64 ) )
         AAdd( aArrayDrives, Chr( i + 64 ) )
      ENDIF
   NEXT

   RETURN aArrayDrives

STATIC PROCEDURE BottomBar()

   LOCAL nRow := MaxRow()
   LOCAL cSpaces
   LOCAL nCol := Int( MaxCol() / 10 ) + 1

   cSpaces := Space( nCol - 8 )

   hb_DispOutAt( nRow, 0,        " 1", 0x7 )
   hb_DispOutAt( nRow, 2,            "Help  " + cSpaces, 0x30 )
   hb_DispOutAt( nRow, nCol,     " 2", 0x7 )
   hb_DispOutAt( nRow, nCol + 2,     "Menu  " + cSpaces, 0x30 )
   hb_DispOutAt( nRow, nCol * 2, " 3", 0x7 )
   hb_DispOutAt( nRow, nCol * 2 + 2, "View  " + cSpaces, 0x30 )
   hb_DispOutAt( nRow, nCol * 3, " 4", 0x7 )
   hb_DispOutAt( nRow, nCol * 3 + 2, "Edit  " + cSpaces, 0x30 )
   hb_DispOutAt( nRow, nCol * 4, " 5", 0x7 )
   hb_DispOutAt( nRow, nCol * 4 + 2, "Copy  " + cSpaces, 0x30 )
   hb_DispOutAt( nRow, nCol * 5, " 6", 0x7 )
   hb_DispOutAt( nRow, nCol * 5 + 2, "RenMov" + cSpaces, 0x30 )
   hb_DispOutAt( nRow, nCol * 6, " 7", 0x7 )
   hb_DispOutAt( nRow, nCol * 6 + 2, "MkDir " + cSpaces, 0x30 )
   hb_DispOutAt( nRow, nCol * 7, " 8", 0x7 )
   hb_DispOutAt( nRow, nCol * 7 + 2, "Delete" + cSpaces, 0x30 )
   hb_DispOutAt( nRow, nCol * 8, " 9", 0x7 )
   hb_DispOutAt( nRow, nCol * 8 + 2, "PullDn" + cSpaces, 0x30 )
   hb_DispOutAt( nRow, nCol * 9, "10", 0x7 )
   hb_DispOutAt( nRow, nCol * 9 + 2, "Quit  " + cSpaces, 0x30 )

   RETURN

STATIC FUNCTION MsgBox( cMessage, aMessage, aOptions )

   LOCAL nMaxRow := 0, nMaxCol := 0
   LOCAL cScreen
   LOCAL aOptionsOK := {}, aPosButtons
   LOCAL lContinue := .T.
   LOCAL i
   LOCAL nChoice := 1
   LOCAL nOpWidth, nWidth, nInitCol, expValue
   LOCAL nOldRow, nOldCol
   LOCAL nKey, nKeyStd
   LOCAL cString
   LOCAL nCol := 0, nColNo := 0

   nOldRow := Row()
   nOldCol := Col()

   FOR EACH i IN hb_defaultValue( aOptions, {} )
      IF HB_ISSTRING( i ) .AND. ! i == ""
         AAdd( aOptionsOK, i )
      ENDIF
   NEXT

   IF Len( aOptionsOK ) == 0
      aOptionsOK := { "Ok" }
   ENDIF


   IF Empty( aMessage )
      cString := ""
   ELSE
      cString := aMessage
      nCol := Len( aMessage )
   ENDIF

   while lContinue

      DispBegin()
      IF nMaxRow <> Int( MaxRow() / 3 ) .OR. nMaxCol <> Int( MaxCol() / 2 )

         nMaxRow := Int( MaxRow() / 3 )
         nMaxCol := Int( MaxCol() / 2 )

         aPosButtons := {}
         nOpWidth := 0

         cScreen := SaveScreen( nMaxRow - 2, nMaxCol - 36, nMaxRow + 4, nMaxCol + 38 )

         AEval( aOptionsOK, {| x | nOpWidth += Len( x ) + 4 } )

         nWidth := nOpWidth + 2
         nInitCol := Int( ( ( MaxCol() - ( nWidth + 2 ) ) / 2 ) + 0.5 )
         expValue := nInitCol + Int( ( nWidth - nOpWidth ) / 2 ) + 2
         AEval( aOptionsOK, {| x | AAdd( aPosButtons, expValue ), expValue += Len( x ) + 4 } )

         hb_DispBox( nMaxRow - 2, nMaxCol - 36, nMaxRow + 3, nMaxCol + 36, hb_UTF8ToStrBox( "┌─┐│┘─└│" ) + " ", 0x8f )
         hb_Shadow( nMaxRow - 2, nMaxCol - 36, nMaxRow + 3, nMaxCol + 36 )
         hb_DispOutAt( nMaxRow - 1, nMaxCol - 34, cMessage, 0x8f )

         FOR i := 1 TO Len( aOptionsOK )
            hb_DispOutAt( nMaxRow + 2, aPosButtons[ i ], " " + aOptionsOK[ i ] + " ", iif( i == nChoice, 0x07, 0x8f ) )
         NEXT

         MsgBoxDisplay( cString, nCol, nColNo )

      ENDIF
      DispEnd()

      MsgBoxDisplay( cString, nCol, nColNo )

      nKey := Inkey( 0 )
      nKeyStd := hb_keyStd( nKey )

      SWITCH nKeyStd
      CASE 27
         lContinue := .F.
         nChoice := 0
         EXIT

      CASE 13
         lContinue := .F.
         EXIT

      CASE 28
         EXIT

      CASE -9
         lContinue := .F.
         nChoice := 0
         EXIT

      CASE 19

         IF nCol > 0
            nCol--
         ELSE
            IF nColNo >= 1
               nColNo--
            ENDIF
         ENDIF

         EXIT

      CASE 4

         IF nCol < 68 .AND. nCol < Len( cString )
            nCol++
         ELSE
            IF nColNo + nCol < Len( cString )
               nColNo++
            ENDIF
         ENDIF

         EXIT

      CASE 1

         nCol := 0

         EXIT

      CASE 6

         nCol := Len( cString )

         EXIT

      CASE 7

         IF nCol >= 0
            cString := Stuff( cString, nCol + 1, 1, "" )
         ENDIF

         EXIT

      CASE 8

         IF nCol > 0
            cString := Stuff( cString, nCol, 1, "" )
            nCol--
         ENDIF

         EXIT

      CASE 9
         IF Len( aOptionsOK ) > 1
            nChoice++
            IF nChoice > Len( aOptionsOK )
               nChoice := 1
            ENDIF
         ENDIF

         FOR i := 1 TO Len( aOptionsOK )
            hb_DispOutAt( nMaxRow + 2, aPosButtons[ i ], " " + aOptionsOK[ i ] + " ", iif( i == nChoice, 0x07, 0x8f ) )
         NEXT

         EXIT

      CASE 1101

         hb_Scroll()
         AutoSize()

         PanelDisplay( aPanelLeft )
         PanelDisplay( aPanelRight )

         ComdLineDisplay( aPanelSelect )

         BottomBar()

         EXIT

      OTHERWISE

         IF ( nKeyStd >= 32 .AND. nKeyStd <= 126 ) .OR. ( nKeyStd >= 160 .AND. nKeyStd <= 255 ) .OR. ! hb_keyChar( nKeyStd ) == ""

            cString := Stuff( cString, nCol + nColNo + 1, 0, hb_keyChar( nKeyStd ) )
            IF nCol < 68
               nCol++
            ELSE
               nColNo++
            ENDIF

         ENDIF

      ENDSWITCH

   ENDDO

   RestScreen( nMaxRow - 2, nMaxCol - 36, nMaxRow + 4, nMaxCol + 38, cScreen )
   SetPos( nOldRow, nOldCol )

   RETURN iif( nChoice == 1, iif( Empty( cString ), 0, cString ), 0 )

STATIC PROCEDURE MsgBoxDisplay( cString, nCol, nColNo )

   LOCAL nMaxRow := Int( MaxRow() / 3 ), nMaxCol := Int( MaxCol() / 2 )

   DispBegin()

   hb_DispOutAt( nMaxRow, nMaxCol - 34, PadR( SubStr( cString, 1 + nColNo, 69 + nColNo ), 69 ) )

   SetPos( nMaxRow, nMaxCol - 34 + nCol )

   DispEnd()

   RETURN

STATIC FUNCTION HC_Alert( cTitle, xMessage, xOptions, nColorNorm, nArg )

   LOCAL nOldCursor := SetCursor( 0 )


   LOCAL aMessage, aOptions, aPos
   LOCAL nColorHigh
   LOCAL nLenOptions, nLenMessage
   LOCAL nWidth := 0
   LOCAL nLenght := 0
   LOCAL nPos
   LOCAL i
   LOCAL nMaxRow := 0, nMaxCol := 0
   LOCAL nRow, nCol
   LOCAL nKey, nKeyStd
   LOCAL nTop, nLeft, nBottom, nRight
   LOCAL nChoice := 1
   LOCAL nMRow, nMCol

   DO CASE
   CASE ValType( cTitle ) == "U"
      cTitle := "OK"
   ENDCASE

   DO CASE
   CASE ValType( xMessage ) == "U"
      aMessage := { "" }
   CASE ValType( xMessage ) == "C"
      aMessage := hb_ATokens( xMessage, ";" )
   CASE ValType( xMessage ) == "A"
      aMessage := xMessage
   CASE ValType( xMessage ) == "N"
      aMessage := hb_ATokens( hb_CStr( xMessage ) )
   ENDCASE

   DO CASE
   CASE ValType( xOptions ) == "U"
      aOptions := { "OK" }
   CASE ValType( xOptions ) == "C"
      aOptions := hb_ATokens( xOptions, ";" )
   CASE ValType( xOptions ) == "A"
      aOptions := xOptions
   ENDCASE

   DO CASE
   CASE ValType( nColorNorm ) == "U"
      nColorNorm := 0x4f
      nColorHigh := 0x1f
   CASE ValType( nColorNorm ) == "N"
      nColorNorm := hb_bitAnd( nColorNorm, 0xff )
      nColorHigh := hb_bitAnd( hb_bitOr( hb_bitShift( nColorNorm, - 4 ), hb_bitShift( nColorNorm, 4 ) ), 0x77 )
   ENDCASE

   nLenOptions := Len( aOptions )
   FOR i := 1 TO nLenOptions
      nWidth += Len( aOptions[ i ] ) + 2
      nLenght += Len( aOptions[ i ] ) + 2
   NEXT


   nLenMessage := Len( aMessage )
   FOR i := 1 TO nLenMessage
      nWidth := Max( nWidth, Len( aMessage[ i ] ) )
   NEXT

   while .T.

      DispBegin()


      IF nMaxRow <> MaxRow( .T. ) .OR. nMaxCol <> iif( nArg == NIL, MaxCol( .T. ), iif( nArg == 0x0, Int( MaxCol( .T. ) / 2 ), MaxCol( .T. ) + Int( MaxCol( .T. ) / 2 ) ) )

         WSelect( 0 )

         nMaxRow := MaxRow( .T. )

         nMaxCol := iif( nArg == NIL, MaxCol( .T. ), iif( nArg == 0x0, Int( MaxCol( .T. ) / 2 ), MaxCol( .T. ) + Int( MaxCol( .T. ) / 2 ) ) )

         nTop    := Int( nMaxRow / 3 ) - 3
         nLeft   := Int( ( nMaxCol - nWidth ) / 2 ) - 2
         nBottom := nTop + 4 + nLenMessage
         nRight  := Int( ( nMaxCol + nWidth ) / 2 ) - 1 + 2

         WClose( 1 )
         WSetShadow( 0x8 )
         WOpen( nTop, nLeft, nBottom, nRight, .T. )

         hb_DispBox( 0, 0, nMaxRow, nMaxCol, hb_UTF8ToStrBox( " █       " ), nColorNorm )
         hb_DispOutAt( 0, 0, Center( cTitle ), hb_bitShift( nColorNorm, 4 ) )

         FOR nPos := 1 TO Len( aMessage )
            hb_DispOutAt( 1 + nPos, 0, Center( aMessage[ nPos ] ), nColorNorm )
         NEXT

      ENDIF


      aPos := {}
      nRow := nPos + 2
      nCol := Int( ( MaxCol() + 1 - nLenght - nLenOptions + 1 ) / 2 )

      FOR i := 1 TO nLenOptions
         AAdd( aPos, nCol )
         hb_DispOutAt( nRow, nCol, " " + aOptions[ i ] + " ", iif( i == nChoice, nColorHigh, nColorNorm ) )
         nCol += Len( aOptions[ i ] ) + 3
      NEXT

      DispEnd()

      nKey := Inkey( 0 )
      nKeyStd := hb_keyStd( nKey )

      DO CASE
      CASE nKeyStd == 27
         nChoice := 0
         EXIT

      CASE nKeyStd == 13 .OR. nKeyStd == 32
         EXIT

      CASE nKeyStd == 1001

         FOR i := 1 TO nLenOptions
            IF MRow() == nPos + 2 .AND. MCol() >= aPos[ i ] .AND. MCol() <= aPos[ i ] + Len( aOptions[ i ] ) + 1
               nChoice := i
            ENDIF
         NEXT

      CASE nKeyStd == 1002

         nMCol := MCol()
         nMRow := MRow()

         IF MRow() == 0 .AND. MCol() >= 0 .AND. MCol() <= MaxCol()

            while MLeftDown()
               WMove( WRow() + MRow() - nMRow, WCol() + MCol() - nMCol )
            ENDDO

         ENDIF

         FOR i := 1 TO nLenOptions
            IF MRow() == nPos + 2 .AND. MCol() >= aPos[ i ] .AND. MCol() <= aPos[ i ] + Len( aOptions[ i ] ) + 1
               nChoice := i
               EXIT
            ENDIF
         NEXT

         IF nChoice == i
            EXIT
         ENDIF

      CASE ( nKeyStd == 19 .OR. nKeyStd == 271 ) .AND. nLenOptions > 1

         nChoice--
         IF nChoice == 0
            nChoice := nLenOptions
         ENDIF

      CASE ( nKeyStd == 4 .OR. nKeyStd == 9 ) .AND. nLenOptions > 1

         nChoice++
         IF nChoice > nLenOptions
            nChoice := 1
         ENDIF

      CASE nKeyStd == 397
         WMove( WRow() - 1, WCol() )

      CASE nKeyStd == 401
         WMove( WRow() + 1, WCol() )

      CASE nKeyStd == 26
         WMove( WRow(), WCol() - 1 )

      CASE nKeyStd == 2
         WMove( WRow(), WCol() + 1 )

      CASE nKeyStd == 1101

         WClose( 1 )

         AutoSize()

         PanelDisplay( aPanelLeft )
         PanelDisplay( aPanelRight )
         ComdLineDisplay( aPanelSelect )

         BottomBar()

      ENDCASE

   ENDDO

   WClose( 1 )
   SetCursor( nOldCursor )


   RETURN iif( nKey == 0, 0, nChoice )

STATIC FUNCTION HC_MenuF2()

   LOCAL nOldCursor := SetCursor( 0 )
   LOCAL cFile := "hc.menu"
   LOCAL cCopyExample := ""
   LOCAL i, aLine, aMenu := {}, cLine
   LOCAL nMaxRow := 0, nMaxCol := 0
   LOCAL nRow := 1
   LOCAL nKey, nKeyStd
   LOCAL nColLength := 0
   LOCAL nTop, nLeft, nBottom, nRight
   LOCAL nChoice := 1
   LOCAL nRowPos := 1, nColPos := 2
   LOCAL nMRow, nMCol

   IF ! hb_vfExists( StartUpPath() + "hc.menu" )


      cCopyExample += "F1:Compilation of my project in Harbour" + hb_eol()
      cCopyExample += Space( 8 ) + "hbmk2 hc.prg" + hb_eol()
      cCopyExample += "F2:Checking version of GCC compiler" + hb_eol()
      cCopyExample += Space( 8 ) + "gcc --version" + hb_eol()
      cCopyExample += "F3:What is my OS version" + hb_eol()
      cCopyExample += Space( 8 ) + "uname -a"


      hb_MemoWrit( StartUpPath() + "hc.menu", cCopyExample )

   ENDIF

   aLine := hb_ATokens( hb_MemoRead( cFile ), .T. )

   FOR i := 1 TO Len( aLine )
      IF SubStr( aLine[ i ], 1, 1 ) == "F"
         AAdd( aMenu, aLine[ i ] )
      ENDIF
   NEXT

   AScan( aMenu, {| str | nColLength := Max( nColLength, Len( str ) ) } )

   while .T.

      DispBegin()

      IF nMaxRow <> MaxRow( .T. ) .OR. nMaxCol <> MaxCol( .T. )

         WSelect( 0 )

         nMaxRow := MaxRow( .T. )
         nMaxCol := MaxCol( .T. )

         nTop    := Int( nMaxRow / 3 ) - 3
         nLeft   := Int( ( nMaxCol - nColLength ) / 2 ) - 2
         nBottom := nTop + 2 + Len( aMenu )
         nRight  := Int( ( nMaxCol + nColLength ) / 2 ) - 1 + 2

         WClose( 1 )
         WSetShadow( 0x8 )
         WOpen( nTop, nLeft, nBottom, nRight, .T. )

         hb_DispBox( 0, 0, nMaxRow, nMaxCol, hb_UTF8ToStrBox( " █       " ), 0x9f )
         hb_DispOutAt( 0, 0, Center( hb_UserName() + "  Menu" ), 0xf0 )

         hb_DispBox( 1, 0, MaxRow(), MaxCol(), hb_UTF8ToStrBox( "┌─┐│┘─└│" ), 0x9f )

      ENDIF

      DispEnd()

      FOR EACH cLine IN aMenu



         hb_DispOutAt( nRowPos + cLine:__enumIndex(), nColPos,  PadR( cLine, nColLength ),  iif( cLine:__enumIndex() == nRow, 0xf, 0x9f ) )

         iif( cLine:__enumIndex() == nRow, nChoice := cLine:__enumIndex(), NIL )

      NEXT

      DispEnd()

      nKey := Inkey( 0 )
      nKeyStd := hb_keyStd( nKey )

      DO CASE
      CASE nKeyStd == 27
         nChoice := 0
         EXIT

      CASE nKeyStd == 13 .OR. nKeyStd == 32
         EXIT

      CASE nKeyStd == 1001

         IF nRowPos < MRow() .AND. nColPos < MCol() .AND. nRowPos + Len( aMenu ) >= MRow() .AND. nColPos + nColLength > MCol()
            nRow := MRow() - nRowPos
         ENDIF

      CASE nKeyStd == 1002

         nMCol := MCol()
         nMRow := MRow()

         IF MRow() == 0 .AND. MCol() >= 0 .AND. MCol() <= MaxCol()

            while MLeftDown()
               WMove( WRow() + MRow() - nMRow, WCol() + MCol() - nMCol )
            ENDDO

         ENDIF

         IF nRowPos < MRow() .AND. nColPos < MCol() .AND. nRowPos + Len( aMenu ) >= MRow() .AND. nColPos + nColLength > MCol()
            RETURN nChoice
         ENDIF

      CASE nKeyStd == 1014

         IF nRowPos < MRow() .AND. nColPos < MCol() .AND. nRowPos + Len( aMenu ) >= MRow() .AND. nColPos + nColLength > MCol()
            IF nRow > 1
               nRow--
            ELSE
               nRow := Len( aMenu )
            ENDIF
         ENDIF

      CASE nKeyStd == 1015

         IF nRowPos < MRow() .AND. nColPos < MCol() .AND. nRowPos + Len( aMenu ) >= MRow() .AND. nColPos + nColLength > MCol()
            IF nRow < Len( aMenu )
               nRow++
            ELSE
               nRow := 1
            ENDIF
         ENDIF

      CASE nKeyStd == 5

         IF nRow > 1
            nRow--
         ELSE
            nRow := Len( aMenu )
         ENDIF

      CASE nKeyStd == 24

         IF nRow < Len( aMenu )
            nRow++
         ELSE
            nRow := 1
         ENDIF

      CASE nKeyStd == 397
         WMove( WRow() - 1, WCol() )

      CASE nKeyStd == 401
         WMove( WRow() + 1, WCol() )

      CASE nKeyStd == 26
         WMove( WRow(), WCol() - 1 )

      CASE nKeyStd == 2
         WMove( WRow(), WCol() + 1 )

      CASE nKeyStd == 1101

         WClose( 1 )

         AutoSize()

         PanelDisplay( aPanelLeft )
         PanelDisplay( aPanelRight )
         ComdLineDisplay( aPanelSelect )

         BottomBar()

      ENDCASE

   ENDDO

   WClose( 1 )
   SetCursor( nOldCursor )

   RETURN iif( nKey == 0, 0, nChoice )

STATIC PROCEDURE HCEdit( cFileName, lArg )

   LOCAL cString
   LOCAL aString
   LOCAL lContinue := .T.
   LOCAL nMaxRow := 0, nMaxCol := 0
   LOCAL nRow := 1, nCol := 0, nRowNo := 0, nColNo := 0
   LOCAL cStringEditingRow
   LOCAL cSubString
   LOCAL lToggleInsert := .F.
   LOCAL nKey, nKeyStd
   LOCAL nOldRow, nOldCol
   LOCAL cScreen
   LOCAL tsDateTime

   nOldRow := Row()
   nOldCol := Col()
   cScreen := SaveScreen( 0, 0, MaxRow(), MaxCol() )

   IF HB_ISSTRING( cFileName )

      cString := hb_MemoRead( cFileName )

      aString := hb_ATokens( cString, .T. )

      while lContinue

         IF nMaxRow <> MaxRow() .OR. nMaxCol <> MaxCol()
            nMaxRow := MaxRow()
            nMaxCol := MaxCol()

            IF nRow > nMaxRow - 1
               nRow := nMaxRow - 1
            ENDIF

            HCEditDisplay( aString, nRow, nCol, nRowNo )

         ENDIF

         DispBegin()

         hb_DispOutAt( 0, 0,  PadR( cFileName + "  ", nMaxCol + 1 ), 0x30 )

         HCEditDisplay( aString, nRow, nCol, nRowNo )

         hb_vfTimeGet( cFileName, @tsDateTime )

         hb_DispOutAt( nMaxRow, 0,  PadR( " Row(" + hb_ntos( nRow + nRowNo ) + ") Col(" + hb_ntos( nCol + 1 ) + ") Size(" + hb_ntos( hb_vfSize( cFileName ) ) + ") Date(" + hb_TToC( tsDateTime ) + ")", nMaxCol + 1 ), 0x30 )
         DispEnd()

         nKey := Inkey( 0 )
         nKeyStd := hb_keyStd( nKey )

         SWITCH nKeyStd

         CASE 27
            lContinue := .F.
            EXIT

         CASE 1002

            IF MRow() > 0 .AND. MCol() > 0 .AND. MRow() < Len( aString ) + 1 .AND. MCol() < nMaxCol
               nRow := MRow()
               nCol := Len( aString[ nRowNo + nRow ] )
            ENDIF

            EXIT

         CASE 1014

            IF nRowNo >= 1
               nRowNo--
            ENDIF

            EXIT

         CASE 1015

            IF nRow + nRowNo < Len( aString )
               nRowNo++
            ENDIF

            EXIT

         CASE 5

            IF nRow > 1
               nRow--
            ELSE
               IF nRowNo >= 1
                  nRowNo--
               ENDIF
            ENDIF

            IF aString[ nRowNo + nRow ] == ""
               nCol  := 0
            ELSE
               IF nCol > Len( aString[ nRowNo + nRow ] )
                  nCol := Len( aString[ nRowNo + nRow ] )
               ENDIF
            ENDIF

            EXIT

         CASE 19

            IF nCol > 0
               nCol--
            ELSE
               IF nColNo > 0
                  nColNo--
               ENDIF
            ENDIF

            EXIT

         CASE 24

            IF nRow < nMaxRow - 1 .AND. nRow < Len( aString )
               nRow++
            ELSE
               IF nRowNo + nRow < Len( aString )
                  nRowNo++
               ENDIF
            ENDIF

            IF aString[ nRowNo + nRow ] == ""
               nCol := 0
            ELSE
               IF nCol > Len( aString[ nRowNo + nRow ] )
                  nCol := Len( aString[ nRowNo + nRow ] )
               ENDIF
            ENDIF

            EXIT

         CASE 4

            IF nCol < Len( aString[ nRowNo + nRow ] )
               nCol++
            ENDIF

            EXIT

         CASE 1

            nCol := 0

            EXIT

         CASE 6

            nCol := Len( aString[ nRowNo + nRow ] )

            EXIT

         CASE 18

            IF nRow <= 1
               IF nRowNo - nMaxRow >= 0
                  nRowNo -= nMaxRow
               ENDIF
            ENDIF
            nRow := 1

            EXIT

         CASE 3

            IF nRow >= nMaxRow - 1
               IF nRowNo + nMaxRow  <= Len( aString )
                  nRowNo += nMaxRow
               ENDIF
            ENDIF
            nRow := Min( nMaxRow - 1, Len( aString ) - nRowNo )

            hb_Scroll( 1, 0, nMaxRow, nMaxCol )

            EXIT

         CASE 31

            nRow := 0
            nRowNo := 0

            EXIT

         CASE 30

            nRow := nMaxRow - 1
            nRowNo := Len( aString ) - nMaxRow + 1

            EXIT

         CASE 13

            IF lArg
               IF aString[ nRowNo + nRow ] == "" .OR. nCol == 0

                  hb_AIns( aString, nRowNo + nRow, "", .T. )
                  nRow++
               ELSE
                  IF nCol == Len( aString[ nRowNo + nRow ] )
                     hb_AIns( aString, nRowNo + nRow + 1, "", .T. )
                     nRow++
                     nCol := 0
                  ELSE
                     cSubString := Right( aString[ nRowNo + nRow ], Len( aString[ nRowNo + nRow ] ) - nCol )
                     cStringEditingRow := aString[ nRowNo + nRow ]
                     aString[ nRowNo + nRow ] := Stuff( cStringEditingRow, nCol + 1, Len( aString[ nRowNo + nRow ] ) - nCol, "" )
                     hb_AIns( aString, nRowNo + nRow + 1, cSubString, .T. )
                     nRow++
                     nCol := 0
                  ENDIF
               ENDIF

               SaveFile( aString, cFileName )

            ENDIF
            EXIT

         CASE 22
            IF lArg
               IF lToggleInsert
                  SetCursor( 1 )
                  lToggleInsert := .F.
               ELSE
                  SetCursor( 2 )
                  lToggleInsert := .T.
               ENDIF
            ENDIF
            EXIT

         CASE 7
            IF lArg
               IF aString[ nRowNo + nRow ] == ""
                  IF nRow >= 0
                     hb_ADel( aString, nRowNo + nRow, .T. )
                  ENDIF
               ELSE
                  IF nCol == Len( aString[ nRowNo + nRow ] )

                     aString[ nRowNo + nRow ] += aString[ nRowNo + nRow + 1 ]

                     hb_ADel( aString, nRowNo + nRow + 1, .T. )
                  ELSE
                     cStringEditingRow := aString[ nRowNo + nRow ]
                     aString[ nRowNo + nRow ] := Stuff( cStringEditingRow, nCol + 1, 1, "" )
                  ENDIF
               ENDIF

               SaveFile( aString, cFileName )

            ENDIF
            EXIT

         CASE 8
            IF lArg
               IF aString[ nRowNo + nRow ] == ""
                  IF nRow > 1
                     hb_ADel( aString, nRowNo + nRow, .T. )
                     nRow--
                     nCol := Len( aString[ nRowNo + nRow ] )
                  ENDIF
               ELSE
                  IF nCol > 0
                     cStringEditingRow := aString[ nRowNo + nRow ]
                     aString[ nRowNo + nRow ] := Stuff( cStringEditingRow, nCol, 1, "" )
                     nCol--
                  ELSE
                     IF nRow > 1
                        IF aString[ nRowNo + nRow - 1 ] == ""
                           nCol := 0
                        ELSE
                           nCol := Len( aString[ nRowNo + nRow - 1 ] )
                        ENDIF

                        aString[ nRowNo + nRow - 1 ] += aString[ nRowNo + nRow ]

                        hb_ADel( aString, nRowNo + nRow, .T. )
                        nRow--
                     ENDIF
                  ENDIF
               ENDIF

               SaveFile( aString, cFileName )

            ENDIF
            EXIT

         CASE 9
            IF lArg
               cStringEditingRow := aString[ nRowNo + nRow ]

               aString[ nRowNo + nRow ] := Stuff( cStringEditingRow, nCol + 1, iif( lToggleInsert, 1, 0 ), "   " )
               nCol += 3

               SaveFile( aString, cFileName )

            ENDIF
            EXIT

         OTHERWISE

            IF lArg
               IF ( nKeyStd >= 32 .AND. nKeyStd <= 126 ) .OR. ( nKeyStd >= 160 .AND. nKeyStd <= 255 ) .OR. ! hb_keyChar( nKeyStd ) == ""

                  cStringEditingRow := aString[ nRowNo + nRow ]
                  aString[ nRowNo + nRow ] := Stuff( cStringEditingRow, nCol + 1, iif( lToggleInsert, 1, 0 ), hb_keyChar( nKeyStd ) )
                  nCol++

                  SaveFile( aString, cFileName )

               ENDIF
            ENDIF

         ENDSWITCH

      ENDDO

   ELSE
      HC_Alert( "Error reading:;" + cFileName )
      RETURN
   ENDIF

   RestScreen( 0, 0, MaxRow(), MaxCol(), cScreen )
   SetPos( nOldRow, nOldCol )

   RETURN

STATIC PROCEDURE HCEditDisplay( aString, nRow, nCol, nRowNo )

   LOCAL i
   LOCAL nMaxRow := MaxRow(), nMaxCol := MaxCol()
   LOCAL nLine

   hb_Scroll( 2, 0, nMaxRow - 2, nMaxCol )

   FOR i := 1 TO nMaxRow

      nLine := i + nRowNo

      IF nLine <= Len( aString )


         hb_DispOutAt( i, 0,  PadR( aString[ nLine ], nMaxCol + 1 ),  iif( i == nRow, 0x8f, 0x7 ) )
      ELSE
         hb_Scroll( i, 0, nMaxRow, nMaxCol + 1 )
         hb_DispOutAt( i, 1, ">> EOF <<", 0x01 )
         EXIT
      ENDIF

   NEXT

   SetPos( nRow, nCol )

   RETURN

STATIC PROCEDURE SaveFile( aString, cFileName )

   LOCAL cString := ""

   AEval( aString, {| e | cString += e + hb_eol() } )
   hb_MemoWrit( cFileName, cString )

   RETURN

STATIC FUNCTION FileError()












































   RETURN {  {   0, "The operation completed successfully." },  {   2, "The system cannot find the file specified." },  {   3, "The system cannot find the path specified." },  {   4, "The system cannot open the file." },  {   5, "Access is denied." },  {   6, "The handle is invalid." },  {   8, "Not enough storage is available to process this command." },  {  15, "The system cannot find the drive specified." },  {  16, "The directory cannot be removed." },  {  17, "The system cannot move the file to a different disk drive." },  {  18, "There are no more files." },  {  19, "Attempted to write to a write-protected disk." },  {  21, "The device is not ready." },  {  23, "Data error (cyclic redundancy check)." },  {  29, "The system cannot write to the specified device." },  {  30, "The system cannot read from the specified device." },  {  32, "The process cannot access the file because ; it is being used by another process." },  {  33, "The process cannot access the file because ; another process has locked a portion of the file." },  {  36, "Too many files opened for sharing." },  {  38, "Reached the end of the file." },  {  62, "Space to store the file waiting to be printed ; is not available on the server." },  {  63, "Your file waiting to be printed was deleted." },  {  80, "The file exists." },  {  82, "The directory or file cannot be created." },  { 110, "The system cannot open the device or file specified." },  { 111, "The file name is too long" },  { 113, "No more internal file identifiers available." },  { 114, "The target internal file identifier is incorrect." },  { 123, "The filename, directory name, ; or volume label syntax is incorrect." },  { 130, "Attempt to use a file handle to an open disk ; partition for an operation other than raw disk I/O." },  { 131, "An attempt was made to move the file pointer ; before the beginning of the file." },  { 132, "The file pointer cannot be set on the specified ; device or file." },  { 138, "The system tried to join a drive ; to a directory on a joined drive." },  { 139, "The system tried to substitute a drive ; to a directory on a substituted drive." },  { 140, "The system tried to join a drive ; to a directory on a substituted drive." },  { 141, "The system tried to SUBST a drive ; to a directory on a joined drive." },  { 143, "The system cannot join or substitute a drive ; to or for a directory on the same drive." },  { 144, "The directory is not a subdirectory of the root directory." },  { 145, "The directory is not empty." },  { 150, "System trace information was not specified ; in your CONFIG.SYS file, or tracing is disallowed." },  { 154, "The volume label you entered exceeds ; the label character limit of the target file system." },  { 167, "Unable to lock a region of a file." },  { 174, "The file system does not support ; atomic changes to the lock type." },  }


FUNCTION Q( xPar )
   RETURN Alert( hb_ValToExp( xPar ) )


FUNCTION StartUpPath()

   LOCAL cDir := ""

   hb_FNameSplit( hb_argv( 0 ), @cDir )

   RETURN cDir
